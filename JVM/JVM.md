### 一、JVM 内存模型
 ![image](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2930353890,3785557893&fm=173&app=25&f=JPEG?w=428&h=379&s=05106532110E5549565520DA010080B2)
#### PC寄存器（程序计数器）
   * 线程私有
   * 可以看作是当前线程所执行的字节码的行号指示器，以便线程切换后恢复执行使用；
   * 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OutOfMemoryError的情况。

#### JVM栈（虚拟机栈）
   * 线程私有
   * JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
  
#### 堆（Heap）
   * 线程共享
   * 唯一目的就是用于存放**对象实例**，是垃圾收集器管理的主要区域；
   
#### 方法区
   * 线程共享
   * 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   * 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。
   * 从 JDK1.7 开始HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。
   * 在 JDK1.8 中，永久代已完全被元空间(Meatspace)所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
   * 方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。
   * 运行时常量池是方法区的一部分。
   * 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。
   * 在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。
   
#### 本地方法栈
   * 线程私有
   * 与虚拟机栈非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

### 二、对象存活判断
   #### 1、引用计数法
   * 描述：
     * 给 Java 对象添加一个引用计数器
     * 每当有一个地方引用它时，计数器 +1；引用失效则 -1；
   * 判断对象存活准则
     * 当计数器不为 0 时，判断该对象存活；否则判断为死亡（计数器 = 0）。
   * 优点
     * 实现简单
     * 判断高效
   * 缺点 
     * 无法解决对象间相互循环引用的问题（即该算法存在判断逻辑的漏洞） 
   * 例子
   ```
    <-- 背景 -->
    // 对象objA 和 objB 都有字段 name
    // 两个对象相互进行引用，除此之外这两个人对象没有任何引用
    objA.name = objB；
    objB.name = objA；
    
    <-- 问题 -->
    // 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收
    // 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象
   ```
   #### 2、可达性分析
   * 方式描述
   将一系列GC Roots对象作为起点，从这些起点开始向下搜索
     * 可作为GC Root 的对象有： 
       * 1.Java虚拟机栈（栈帧的本地变量表）中引用的对象
       * 2.本地方法栈中JNI引用的对象
       * 3.方法区中常量、类静态属性引用的对象
   ![image](https://upload-images.jianshu.io/upload_images/944365-d4e8050dd88ed216.png)
   * 判断 对象是否可达 标准
     * 当一个对象到 GC Roots 没有任何引用链相连时，则判断该对象不可达 
   * 特别注意
     * 可达性分析 仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡
     * 当在 可达性分析 中判断不可达的对象，只是“被判刑” = 还没真正死亡
   ```
      不可达对象会被放在”即将回收“的集合里。
   ```
   * 要判断一个对象真正死亡，还需要经历两个阶段：
     * 1.第一次标记 & 筛选 
       * 对象在可达性分析中被判断为不可达后，会被第一次标记&准备被筛选
          *  a. 不筛选：继续留在 ”即将回收“的集合里，等待回收；
          *  b. 筛选：从 ”即将回收“的集合取出  
       *  筛选的标准：该对象是否有必要执行 finalize()方法   
          * 若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；
          * 若没必要执行，判断该对象死亡，不筛选 并等待回收 
                当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”
     * 2.第二次标记&筛选
       * 当对象经过了第一次的标记 & 筛选，会被进行第二次标记 & 准备被进行筛选
       * 方式描述
          * 该对象会被放到一个 F-Queue 队列中，并由 虚拟机自动建立、优先级低的Finalizer 线程去执行 队列中该对象的finalize()
            * finalize()只会被执行一次
            * 但并不承诺等待finalize()运行结束。这是为了防止 finalize()执行缓慢 / 停止 使得 F-Queue队列其他对象永久等待
       * 筛选标准
          * 在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收
          
          
### 垃圾收集器类型