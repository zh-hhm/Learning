### HashMap
    
    HashMap底层是由数据+单链表实现，数组Entry 里面包含着key-value、hash值，和用于单向链表的 next。
    capacity 数组当前的容量 2的n次方 默认为16
    loadFactor 加载因子 默认为0.75 是哈希表在其容量自动添加之前可以达到多满的一种尺度
    threshold 扩容的阈值  capacity*loadFactor 
    
        当我们使用HashMap中put元素时，通过key的hash值来找到元素在数组中的位置，然后就可把元素放到对应的位置上。
    如果这个元素所在的位置上已经有其他元素了，那么在同一个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放入链尾。
        当我们使用get元素时，首先需要计算key的hash值，找到数组中对应位置的元素，然后通过key的equals方法在对应位置的链表中找到元素。
        
     
###  HashMap的扩容
    当hashmap中的元素越来越多的时候，碰撞几率也就越来越高，为了提高查询效率，就要对hashmap数组进行扩容。当hashmap中元素个数超过 数组大小（capacity）* loadFactor
    就会自动进行扩容。
    eg：初始容量为16，实际容量=16*0.75=12，那么就是当数组中元素个数超过12的时候，数组的大小会扩展为2*16=32，即扩大一倍。
    
#### Hashmap的结构，1.7和1.8有哪些区别
    不同点：
    （1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。
    
    （2）扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 & length-1）
    2、而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。


### Hashtable实现线程安全的原理
    Hashtable是通过使用了 synchronized 关键字来保证其线程安全。 在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，
    这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。